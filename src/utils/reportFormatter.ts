import { Vulnerability } from "../types/Vulnerability";

/**
 * Formats and displays the vulnerability scan results
 *
 * @param vulnerabilities - Array of vulnerabilities to display
 */
export function formatReport(vulnerabilities: Vulnerability[]): void {
  console.log("\nüìä MCP SECURITY SCAN RESULTS");
  console.log("===============================");
  console.log(
    "üî¨ Based on research from VulnerableMCP, HiddenLayer, Invariant Labs, Trail of Bits, and PromptHub\n"
  );

  if (vulnerabilities.length === 0) {
    console.log("‚úÖ No vulnerabilities detected!");
    return;
  }

  const severityCounts = vulnerabilities.reduce((acc, vuln) => {
    acc[vuln.severity] = (acc[vuln.severity] || 0) + 1;
    return acc;
  }, {} as Record<string, number>);

  const categoryCounts = vulnerabilities.reduce((acc, vuln) => {
    acc[vuln.category] = (acc[vuln.category] || 0) + 1;
    return acc;
  }, {} as Record<string, number>);

  console.log("üìà Summary by Severity:");
  Object.entries(severityCounts).forEach(([severity, count]) => {
    const emoji =
      severity === "critical"
        ? "üö®"
        : severity === "high"
        ? "‚ö†Ô∏è"
        : severity === "medium"
        ? "‚ö°"
        : "üí°";
    console.log(`  ${emoji} ${severity.toUpperCase()}: ${count}`);
  });

  console.log("\nüìä Summary by Category:");
  Object.entries(categoryCounts).forEach(([category, count]) => {
    const emoji = getCategoryEmoji(category);
    console.log(`  ${emoji} ${category}: ${count}`);
  });

  console.log("\nüîç Detailed Results:");
  console.log("--------------------");

  // Sort by severity (critical first)
  const severityOrder = { critical: 0, high: 1, medium: 2, low: 3 };
  const sortedVulns = vulnerabilities.sort(
    (a, b) => severityOrder[a.severity] - severityOrder[b.severity]
  );

  sortedVulns.forEach((vuln, index) => {
    const severityEmoji =
      vuln.severity === "critical"
        ? "üö®"
        : vuln.severity === "high"
        ? "‚ö†Ô∏è"
        : vuln.severity === "medium"
        ? "‚ö°"
        : "üí°";

    console.log(`\n${index + 1}. ${severityEmoji} ${vuln.message}`);
    console.log(`   üìã ID: ${vuln.id}`);
    console.log(`   üéØ Severity: ${vuln.severity.toUpperCase()}`);
    console.log(`   üìÇ Category: ${vuln.category}`);

    if (vuln.source) {
      console.log(`   üìö Source: ${vuln.source}`);
    }

    if (vuln.file) {
      console.log(
        `   üìç Location: ${vuln.file}${vuln.line ? `:${vuln.line}` : ""}`
      );
    }

    if (vuln.evidence) {
      console.log(`   üîç Evidence: ${vuln.evidence}`);
    }
  });

  console.log("\nüõ°Ô∏è REMEDIATION GUIDANCE");
  console.log("=======================");

  const categories = [...new Set(vulnerabilities.map((v) => v.category))];
  categories.forEach((category) => {
    console.log(
      `\n${getCategoryEmoji(category)} ${category
        .toUpperCase()
        .replace("-", " ")}:`
    );
    console.log(getRemediationAdvice(category));
  });

  // Add statistics from research
  console.log("\nüìä RESEARCH STATISTICS");
  console.log("======================");
  console.log("üìà Based on PromptHub analysis of public MCP servers:");
  console.log("   ‚Ä¢ 43% allow command injection attacks");
  console.log("   ‚Ä¢ 30% vulnerable to SSRF (fetch any URL)");
  console.log("   ‚Ä¢ 22% leak files outside intended directories");
  console.log("\nüî¨ Novel attack vectors documented by security researchers:");
  console.log("   ‚Ä¢ Parameter injection (HiddenLayer) - extracts AI context");
  console.log(
    "   ‚Ä¢ Toxic agent flows (Invariant Labs) - cross-repository attacks"
  );
  console.log(
    "   ‚Ä¢ Tool poisoning (Invariant Labs) - hidden malicious instructions"
  );
  console.log(
    "   ‚Ä¢ Conversation exfiltration (Trail of Bits) - steals chat history"
  );
  console.log("   ‚Ä¢ ANSI injection (Trail of Bits) - hides malicious content");
}

/**
 * Gets the appropriate emoji for a vulnerability category
 *
 * @param category - The vulnerability category
 * @returns Emoji representing the category
 */
export function getCategoryEmoji(category: string): string {
  const emojis: Record<string, string> = {
    "credential-leak": "üîë",
    "tool-poisoning": "üß™",
    "data-exfiltration": "üì§",
    "prompt-injection": "üíâ",
    "tool-mutation": "üîÑ",
    "steganographic-attack": "üé≠",
    "protocol-violation": "üìã",
    "input-validation": "üõ°Ô∏è",
    "server-spoofing": "üé≠",
    "toxic-flow": "üåä",
    "access-control": "üîê",
    documentation: "üìñ",
  };
  return emojis[category] || "‚ö†Ô∏è";
}

/**
 * Provides remediation advice for a specific vulnerability category
 *
 * @param category - The vulnerability category
 * @returns Detailed remediation guidance
 */
export function getRemediationAdvice(category: string): string {
  const advice: Record<string, string> = {
    "credential-leak":
      "  ‚Ä¢ Use encrypted storage for all API tokens and secrets\n" +
      "  ‚Ä¢ Implement proper credential rotation policies\n" +
      "  ‚Ä¢ Never commit secrets to version control\n" +
      "  ‚Ä¢ Use environment variables with proper access controls\n" +
      "  ‚Ä¢ Set restrictive file permissions (600) for credential files\n" +
      "  ‚Ä¢ Consider using secret management services (HashiCorp Vault, AWS Secrets Manager)",

    "tool-poisoning":
      "  ‚Ä¢ Implement static analysis of all tool descriptions\n" +
      "  ‚Ä¢ Manually review every tool before deployment\n" +
      "  ‚Ä¢ Use allowlists for acceptable tool description patterns\n" +
      "  ‚Ä¢ Implement tool integrity checks and versioning\n" +
      "  ‚Ä¢ Monitor for deceptive naming patterns\n" +
      "  ‚Ä¢ Pin tool versions and verify signed hashes",

    "data-exfiltration":
      "  ‚Ä¢ Validate ALL function parameters are actually used\n" +
      "  ‚Ä¢ Implement parameter allowlists - reject unknown parameters\n" +
      "  ‚Ä¢ Monitor for suspicious parameter usage patterns\n" +
      "  ‚Ä¢ Add circuit breakers for unusual data access\n" +
      "  ‚Ä¢ Implement semantic analysis of tool outputs\n" +
      "  ‚Ä¢ Log and alert on potential exfiltration attempts",

    "prompt-injection":
      "  ‚Ä¢ Sanitize all tool descriptions and external content\n" +
      "  ‚Ä¢ Filter out instruction-like patterns in external data\n" +
      "  ‚Ä¢ Implement content security policies for tool descriptions\n" +
      "  ‚Ä¢ Use allowlists for acceptable prompt patterns\n" +
      "  ‚Ä¢ Cap token limits for retrieved content\n" +
      "  ‚Ä¢ Pattern-scan results before feeding to LLM",

    "tool-mutation":
      "  ‚Ä¢ Lock tool definitions after initial approval\n" +
      "  ‚Ä¢ Implement comprehensive tool versioning\n" +
      "  ‚Ä¢ Use unique tool names to avoid collisions\n" +
      "  ‚Ä¢ Add integrity checks for tool definitions\n" +
      "  ‚Ä¢ Monitor for dynamic tool modifications\n" +
      "  ‚Ä¢ Implement change detection and user alerts",

    "steganographic-attack":
      "  ‚Ä¢ Filter all ANSI escape sequences from tool content\n" +
      "  ‚Ä¢ Validate content doesn't contain excessive whitespace\n" +
      "  ‚Ä¢ Implement visual inspection of tool descriptions\n" +
      "  ‚Ä¢ Use plaintext-only tool description policies\n" +
      "  ‚Ä¢ Monitor for hidden content patterns\n" +
      "  ‚Ä¢ Implement content normalization before display",

    "protocol-violation":
      "  ‚Ä¢ Never include session IDs in URL paths\n" +
      "  ‚Ä¢ Always use HTTPS for transport security\n" +
      "  ‚Ä¢ Follow MCP protocol specifications strictly\n" +
      "  ‚Ä¢ Implement proper error handling\n" +
      "  ‚Ä¢ Use secure headers and transport security\n" +
      "  ‚Ä¢ Regular protocol compliance audits",

    "input-validation":
      "  ‚Ä¢ Validate and sanitize ALL user inputs\n" +
      "  ‚Ä¢ Use parameterized queries and safe parsing\n" +
      "  ‚Ä¢ Implement strict path validation (prevent ../)\n" +
      "  ‚Ä¢ Use allowlists instead of blocklists\n" +
      "  ‚Ä¢ Never execute user-controlled commands directly\n" +
      "  ‚Ä¢ Implement URL validation to prevent SSRF",

    "server-spoofing":
      "  ‚Ä¢ Only use servers from trusted sources\n" +
      "  ‚Ä¢ Implement server identity verification\n" +
      "  ‚Ä¢ Monitor for suspicious server names\n" +
      "  ‚Ä¢ Use certificate pinning for server authentication\n" +
      "  ‚Ä¢ Isolate high-risk servers in separate environments\n" +
      "  ‚Ä¢ Log all cross-server interactions",

    "toxic-flow":
      "  ‚Ä¢ Sanitize all external data before processing\n" +
      "  ‚Ä¢ Implement granular boundary controls\n" +
      "  ‚Ä¢ Require explicit approval for cross-boundary operations\n" +
      "  ‚Ä¢ Monitor unusual access patterns\n" +
      "  ‚Ä¢ Use allowlists for authorized resource combinations\n" +
      "  ‚Ä¢ Implement semantic analysis of external content",

    "access-control":
      "  ‚Ä¢ Apply principle of least privilege\n" +
      "  ‚Ä¢ Implement role-based access control\n" +
      "  ‚Ä¢ Avoid consent fatigue through smart batching\n" +
      "  ‚Ä¢ Regular permission audits and cleanup\n" +
      "  ‚Ä¢ Use scoped API tokens when possible\n" +
      "  ‚Ä¢ Document security assumptions clearly",
  };

  return (
    advice[category] || "  ‚Ä¢ Review security best practices for this category"
  );
}
